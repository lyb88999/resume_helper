# 简历优化系统 - 技术架构设计

## 1. 架构概述

简历优化系统采用现代化的微服务架构，基于云原生技术栈构建，具备高可用、高性能、可扩展的特性。系统整体分为七个核心层次：用户层、前端层、网关层、微服务层、AI层、数据层和基础设施层。

## 2. 分层架构详解

### 2.1 用户层 (User Layer)

**职责**: 提供多渠道用户接入

- **Web用户**: 通过浏览器访问的PC端用户
- **移动端用户**: 通过移动应用访问的用户
- **API用户**: 通过API接口集成的第三方用户

**技术特性**:

- 多终端适配
- 响应式设计
- 无障碍支持

### 2.2 前端层 (Frontend Layer)

**技术栈**: Vue 3 + TypeScript + Vite

**核心组件**:

- **简历上传组件**: 支持多格式文件上传，拖拽上传，进度显示
- **在线编辑器**: 富文本编辑，实时预览，模板应用
- **结果展示组件**: 分析结果可视化，建议列表，评分展示
- **知识库管理**: 知识文档CRUD，分类管理，搜索功能
- **用户管理界面**: 用户信息，订阅管理，使用统计

**特性**:

```typescript
// 状态管理 - Pinia
export const useResumeStore = defineStore('resume', {
  state: () => ({
    currentResume: null,
    analysisResult: null,
    suggestions: [],
    isAnalyzing: false
  }),
  
  actions: {
    async uploadResume(file: File) {
      this.isAnalyzing = true
      try {
        const result = await api.uploadResume(file)
        this.currentResume = result
        return result
      } finally {
        this.isAnalyzing = false
      }
    }
  }
})

// 组件示例
<template>
  <div class="resume-upload">
    <el-upload
      :action="uploadUrl"
      :before-upload="beforeUpload"
      :on-progress="onProgress"
      :on-success="onSuccess"
      drag
      multiple
      accept=".pdf,.md,.docx"
    >
      <el-icon><upload-filled /></el-icon>
      <div>拖拽文件到此处，或<em>点击上传</em></div>
    </el-upload>
  </div>
</template>
```

### 2.3 网关层 (Gateway Layer)

**技术栈**: Kratos Gateway + Consul

**核心功能**:

- **路由分发**: 基于路径和服务的智能路由
- **认证服务**: JWT Token验证，OAuth2.0集成
- **限流服务**: 基于用户/IP的请求限流
- **日志收集**: 请求响应日志，性能监控

**配置示例**:

```yaml
# gateway.yaml
server:
  http:
    addr: 0.0.0.0:8080
    timeout: 30s
  
discovery:
  consul:
    address: consul:8500
  
middleware:
  - cors
  - logging
  - ratelimit
  - auth
  
routes:
  - path: /api/v1/users/*
    service: user-service
    middleware: [auth, ratelimit]
  - path: /api/v1/resumes/*
    service: resume-service
    middleware: [auth, ratelimit]
```

### 2.4 微服务层 (Microservice Layer)

**技术栈**: Go + Kratos v2 + gRPC

#### 2.4.1 用户域服务

**用户服务 (User Service)**

```go
// 用户服务接口定义
type UserServiceServer interface {
    Register(context.Context, *RegisterRequest) (*RegisterResponse, error)
    Login(context.Context, *LoginRequest) (*LoginResponse, error)
    GetProfile(context.Context, *GetProfileRequest) (*GetProfileResponse, error)
    UpdateProfile(context.Context, *UpdateProfileRequest) (*UpdateProfileResponse, error)
}

// 服务实现
type userService struct {
    repo UserRepository
    auth AuthService
    log  *log.Helper
}

func (s *userService) Register(ctx context.Context, req *RegisterRequest) (*RegisterResponse, error) {
    // 用户注册逻辑
    user := &User{
        Username: req.Username,
        Email:    req.Email,
        Password: s.hashPassword(req.Password),
    }
  
    if err := s.repo.Create(ctx, user); err != nil {
        return nil, err
    }
  
    token, err := s.auth.GenerateToken(user.ID)
    if err != nil {
        return nil, err
    }
  
    return &RegisterResponse{
        User:  user.ToProto(),
        Token: token,
    }, nil
}
```

**认证服务 (Auth Service)**

- JWT Token生成和验证
- 双因子认证支持
- 权限控制和角色管理

**权限服务 (Permission Service)**

- RBAC权限模型
- 资源访问控制
- 权限缓存和更新

#### 2.4.2 文件域服务

**文件服务 (File Service)**

```go
// 文件服务接口
type FileServiceServer interface {
    Upload(context.Context, *UploadRequest) (*UploadResponse, error)
    Download(context.Context, *DownloadRequest) (*DownloadResponse, error)
    Delete(context.Context, *DeleteRequest) (*DeleteResponse, error)
    GetMetadata(context.Context, *GetMetadataRequest) (*GetMetadataResponse, error)
}

// 文件上传实现
func (s *fileService) Upload(ctx context.Context, req *UploadRequest) (*UploadResponse, error) {
    // 文件验证
    if err := s.validateFile(req.File); err != nil {
        return nil, err
    }
  
    // 生成文件ID和路径
    fileID := uuid.New().String()
    filePath := s.generateFilePath(fileID, req.Filename)
  
    // 上传到对象存储
    if err := s.storage.Put(ctx, filePath, req.File); err != nil {
        return nil, err
    }
  
    // 保存文件元数据
    metadata := &FileMetadata{
        ID:       fileID,
        Filename: req.Filename,
        Size:     len(req.File),
        Path:     filePath,
        UserID:   req.UserID,
    }
  
    if err := s.repo.Save(ctx, metadata); err != nil {
        return nil, err
    }
  
    // 发送处理消息
    s.publisher.Publish(ctx, "file.uploaded", &FileUploadedEvent{
        FileID: fileID,
        UserID: req.UserID,
        Type:   req.FileType,
    })
  
    return &UploadResponse{
        FileID: fileID,
        Status: "uploaded",
    }, nil
}
```

**存储服务 (Storage Service)**

- 对象存储抽象
- 多云存储支持
- 文件生命周期管理

#### 2.4.3 分析域服务

**解析服务 (Parser Service)**

```go
// 解析服务实现
type parserService struct {
    pdfParser      PDFParser
    markdownParser MarkdownParser
    wordParser     WordParser
    publisher      MessagePublisher
}

func (s *parserService) ParseDocument(ctx context.Context, req *ParseRequest) (*ParseResponse, error) {
    // 根据文件类型选择解析器
    var parser DocumentParser
    switch req.FileType {
    case "pdf":
        parser = s.pdfParser
    case "md":
        parser = s.markdownParser
    case "docx":
        parser = s.wordParser
    default:
        return nil, errors.New("unsupported file type")
    }
  
    // 解析文档
    content, err := parser.Parse(ctx, req.FilePath)
    if err != nil {
        return nil, err
    }
  
    // 文本清洗
    cleanedContent := s.cleanText(content)
  
    // 发送分析消息
    s.publisher.Publish(ctx, "document.parsed", &DocumentParsedEvent{
        ResumeID: req.ResumeID,
        Content:  cleanedContent,
    })
  
    return &ParseResponse{
        Content: cleanedContent,
        Status:  "parsed",
    }, nil
}
```

**AI分析服务 (AI Analysis Service)**

- Eino工作流调度
- 分析结果缓存
- 异步任务处理

#### 2.4.4 知识域服务

**知识库服务 (Knowledge Service)**

```go
// 知识库服务
type knowledgeService struct {
    repo      KnowledgeRepository
    embedding EmbeddingService
    vector    VectorService
}

func (s *knowledgeService) AddDocument(ctx context.Context, req *AddDocumentRequest) (*AddDocumentResponse, error) {
    // 文档预处理
    chunks := s.splitDocument(req.Content)
  
    // 生成向量
    vectors, err := s.embedding.Embed(ctx, chunks)
    if err != nil {
        return nil, err
    }
  
    // 保存文档
    doc := &KnowledgeDocument{
        Title:    req.Title,
        Content:  req.Content,
        Category: req.Category,
        Tags:     req.Tags,
    }
  
    if err := s.repo.Save(ctx, doc); err != nil {
        return nil, err
    }
  
    // 保存向量
    for i, chunk := range chunks {
        embedding := &DocumentEmbedding{
            DocID:     doc.ID,
            ChunkID:   fmt.Sprintf("%s_%d", doc.ID, i),
            Content:   chunk,
            Vector:    vectors[i],
            Metadata:  doc.Metadata(),
        }
      
        if err := s.vector.Index(ctx, embedding); err != nil {
            return nil, err
        }
    }
  
    return &AddDocumentResponse{
        DocumentID: doc.ID,
        Status:     "indexed",
    }, nil
}
```

**向量服务 (Vector Service)**

- Milvus集成
- 相似度搜索
- 向量索引管理

#### 2.4.5 通知域服务

**通知服务 (Notification Service)**

- 多渠道通知（邮件、短信、推送）
- 通知模板管理
- 发送状态跟踪

### 2.5 AI层 (AI Layer)

**技术栈**: Eino Framework + 多模型集成

#### 2.5.1 模型层

```go
// 模型配置
type ModelConfig struct {
    Primary   ChatModelConfig   `yaml:"primary"`
    Secondary ChatModelConfig   `yaml:"secondary"`
    Embedding EmbeddingConfig   `yaml:"embedding"`
}

type ChatModelConfig struct {
    Provider string `yaml:"provider"`
    Model    string `yaml:"model"`
    APIKey   string `yaml:"api_key"`
    Timeout  time.Duration `yaml:"timeout"`
    MaxRetries int `yaml:"max_retries"`
}

// 模型管理器
type ModelManager struct {
    primary   chatmodel.ChatModel
    secondary chatmodel.ChatModel
    embedding embedding.Embedder
}

func NewModelManager(config ModelConfig) *ModelManager {
    primary := createChatModel(config.Primary)
    secondary := createChatModel(config.Secondary)
    embeddingModel := createEmbedding(config.Embedding)
  
    return &ModelManager{
        primary:   primary,
        secondary: secondary,
        embedding: embeddingModel,
    }
}
```

#### 2.5.2 编排层

详细实现见《Eino编排设计.md》文档

#### 2.5.3 工具层

```go
// PDF解析器
type PDFParser struct {
    ocr OCRService
}

func (p *PDFParser) Parse(ctx context.Context, filePath string) (string, error) {
    // 使用pdfplumber提取文本
    text, err := pdfplumber.ExtractText(filePath)
    if err != nil {
        return "", err
    }
  
    // 如果文本提取失败，使用OCR
    if len(strings.TrimSpace(text)) == 0 {
        return p.ocr.Recognize(ctx, filePath)
    }
  
    return text, nil
}

// Markdown解析器
type MarkdownParser struct{}

func (p *MarkdownParser) Parse(ctx context.Context, filePath string) (string, error) {
    content, err := ioutil.ReadFile(filePath)
    if err != nil {
        return "", err
    }
  
    // 解析Markdown结构
    md := markdown.New(markdown.XHTMLOutput(true))
    html := md.RenderToString(content)
  
    // 提取纯文本
    text := extractTextFromHTML(html)
    return text, nil
}
```

### 2.6 数据层 (Data Layer)

#### 2.6.1 关系数据库 (PostgreSQL)

```sql
-- 数据库配置
-- 主库：用户数据、简历元数据
-- 从库：只读查询分离

-- 分库分表策略
-- 用户表：按用户ID范围分片
-- 简历表：按用户ID分片
-- 分析结果表：按时间分区

-- 索引策略
CREATE INDEX idx_users_email ON users(email);
CREATE INDEX idx_resumes_user_id ON resumes(user_id);
CREATE INDEX idx_resumes_created_at ON resumes(created_at);
CREATE INDEX idx_analysis_resume_id ON resume_analysis(resume_id);
```

#### 2.6.2 文档数据库 (MongoDB)

```javascript
// MongoDB集合设计
db.documents.createIndex({ "user_id": 1, "created_at": -1 })
db.documents.createIndex({ "category": 1, "tags": 1 })
db.documents.createIndex({ "content": "text" })

// 分片配置
sh.enableSharding("resume_db")
sh.shardCollection("resume_db.documents", { "user_id": 1 })
```

#### 2.6.3 向量数据库 (Milvus)

```python
# Milvus集合配置
from pymilvus import Collection, FieldSchema, CollectionSchema, DataType

# 定义字段
fields = [
    FieldSchema(name="id", dtype=DataType.VARCHAR, max_length=100, is_primary=True),
    FieldSchema(name="doc_id", dtype=DataType.VARCHAR, max_length=100),
    FieldSchema(name="content", dtype=DataType.VARCHAR, max_length=2000),
    FieldSchema(name="vector", dtype=DataType.FLOAT_VECTOR, dim=1536),
    FieldSchema(name="metadata", dtype=DataType.JSON)
]

# 创建集合
schema = CollectionSchema(fields=fields, description="Resume knowledge embeddings")
collection = Collection(name="resume_knowledge", schema=schema)

# 创建索引
index_params = {
    "index_type": "IVF_FLAT",
    "metric_type": "COSINE",
    "params": {"nlist": 128}
}
collection.create_index(field_name="vector", index_params=index_params)
```

#### 2.6.4 缓存层 (Redis)

```yaml
# Redis配置
redis:
  cluster:
    nodes:
      - redis-node1:6379
      - redis-node2:6379
      - redis-node3:6379
  
  # 缓存策略
  user_session:
    ttl: 24h
    pattern: "session:*"
  
  analysis_result:
    ttl: 1h
    pattern: "analysis:*"
  
  rate_limit:
    ttl: 1m
    pattern: "rate:*"
```

### 2.7 基础设施层 (Infrastructure Layer)

#### 2.7.1 消息队列 (RabbitMQ)

```yaml
# 队列配置
queues:
  file_processing:
    durable: true
    auto_delete: false
    routing_key: "file.upload"
  
  ai_analysis:
    durable: true
    auto_delete: false
    routing_key: "analysis.request"
  
  notification:
    durable: true
    auto_delete: false
    routing_key: "notification.send"

# 交换器配置
exchanges:
  resume_events:
    type: topic
    durable: true
```

#### 2.7.2 服务注册发现 (Consul)

```yaml
# Consul配置
consul:
  datacenter: dc1
  data_dir: /opt/consul/data
  log_level: INFO
  node_name: consul-server
  
  server: true
  bootstrap_expect: 3
  
  connect:
    enabled: true
  
  ui_config:
    enabled: true
  
  client_addr: "0.0.0.0"
  bind_addr: "{{ GetInterfaceIP \"eth0\" }}"
```

#### 2.7.3 监控系统

**Prometheus配置**:

```yaml
global:
  scrape_interval: 15s
  evaluation_interval: 15s

scrape_configs:
  - job_name: 'kratos-services'
    consul_sd_configs:
      - server: 'consul:8500'
    relabel_configs:
      - source_labels: [__meta_consul_tags]
        regex: .*,metrics,.*
        action: keep
```

**Grafana Dashboard**:

- 服务性能监控
- 业务指标展示
- 告警规则配置

#### 2.7.4 容器化部署 (Kubernetes)

```yaml
# Deployment配置示例
apiVersion: apps/v1
kind: Deployment
metadata:
  name: user-service
spec:
  replicas: 3
  selector:
    matchLabels:
      app: user-service
  template:
    metadata:
      labels:
        app: user-service
    spec:
      containers:
      - name: user-service
        image: resumeoptim/user-service:v1.0.0
        ports:
        - containerPort: 8080
        - containerPort: 9090
        env:
        - name: CONSUL_ADDR
          value: "consul:8500"
        - name: DB_HOST
          valueFrom:
            secretKeyRef:
              name: db-secret
              key: host
        resources:
          requests:
            memory: "256Mi"
            cpu: "250m"
          limits:
            memory: "512Mi"
            cpu: "500m"
        livenessProbe:
          httpGet:
            path: /health
            port: 8080
          initialDelaySeconds: 30
          periodSeconds: 10
        readinessProbe:
          httpGet:
            path: /ready
            port: 8080
          initialDelaySeconds: 5
          periodSeconds: 5

---
apiVersion: v1
kind: Service
metadata:
  name: user-service
spec:
  selector:
    app: user-service
  ports:
  - name: http
    port: 80
    targetPort: 8080
  - name: metrics
    port: 9090
    targetPort: 9090
  type: ClusterIP
```

## 3. 技术选型理由

### 3.1 前端技术选型

**Vue 3 + TypeScript**:

- 组合式API提供更好的逻辑复用
- TypeScript提供类型安全
- 生态丰富，社区活跃

**Element Plus**:

- 企业级UI组件库
- 丰富的组件支持
- 良好的可定制性

### 3.2 后端技术选型

**Go + Kratos**:

- 高性能，低资源消耗
- 强类型系统，编译时错误检查
- Kratos提供完整的微服务解决方案

**PostgreSQL + MongoDB**:

- PostgreSQL：事务性强，SQL标准
- MongoDB：文档存储，Schema灵活

**Milvus**:

- 专业的向量数据库
- 高性能相似度搜索
- 分布式架构支持

### 3.3 AI技术选型

**Eino Framework**:

- 字节跳动开源，生产验证
- 完整的LLM应用开发框架
- 支持多模型集成

**多模型策略**:

- GPT-4：复杂推理和分析
- Claude-3.5：文本理解和生成
- 本地模型：数据安全场景

## 4. 非功能性需求

### 4.1 性能要求

**响应时间**:

- API响应时间 < 500ms
- 页面加载时间 < 2s
- 文件上传时间 < 5s (10MB)
- AI分析时间 < 60s

**吞吐量**:

- API QPS > 10,000
- 并发用户数 > 10,000
- 文件上传并发 > 500

### 4.2 可用性要求

**系统可用性**: 99.9%
**故障恢复时间**: < 5分钟
**数据一致性**: 最终一致性
**备份策略**: 每日备份，保留30天

### 4.3 扩展性要求

**水平扩展**: 支持服务实例动态伸缩
**存储扩展**: 支持分布式存储扩容
**流量扩展**: 支持负载均衡和流量分发

### 4.4 安全性要求

**数据加密**: AES-256静态加密，TLS传输加密
**访问控制**: RBAC权限模型
**审计日志**: 完整的操作审计记录
**数据脱敏**: 生产环境敏感数据脱敏

## 5. 部署架构

### 5.1 环境规划

**开发环境**:

- 单机部署
- 内存数据库
- Mock AI服务

**测试环境**:

- 小规模集群
- 真实数据库
- 集成测试

**生产环境**:

- 高可用集群
- 分布式存储
- 完整监控

### 5.2 部署策略

**滚动发布**: 零停机发布
**蓝绿部署**: 快速回滚能力
**金丝雀发布**: 风险控制发布

### 5.3 监控告警

**系统监控**:

- CPU、内存、磁盘使用率
- 网络流量和延迟
- 服务健康检查

**业务监控**:

- 用户活跃度
- 接口成功率
- 业务转化率

**告警策略**:

- 分级告警机制
- 多渠道通知
- 自动故障恢复

## 6. 技术演进规划

### 6.1 短期目标 (3个月)

- 完成MVP版本开发
- 基础功能验证
- 性能基准测试

### 6.2 中期目标 (6个月)

- 完善功能特性
- 性能优化
- 用户体验提升

### 6.3 长期目标 (12个月)

- 国际化支持
- 多云部署
- AI能力增强

---

**文档版本**: v1.0
**创建时间**: 2025年
**最后更新**: 2025年
**负责人**: 技术架构团队
